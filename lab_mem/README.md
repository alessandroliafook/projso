# Políticas de Reposição de Páginas - Laboratório 4

## Motivação

A atividade consitui em uma análise de eficiência de cinco políticas de reposição de páginas na memória, tendo uma sexta política como opcional. 

O objetivo será avaliar o grau de eficiência de cada política, considerando o parâmetro *page fault*, a partir de simulações a serem realizadas.

## Políticas

As políticas de reposição de páginas a serem apreciadas serão **FIFO**, **Second-chance**, **LRU**, **NRU**, **Aging**. Como política opcional teremos a avaliação da política **Bélády**. 

Desta forma, necessário iniciar com uma apresentação dos conceitos de cada política que já estarão ordenadas conforme a expectativa de grau de eficiência:

1. **FIFO** - Substitui a página que foi carregada na memória a mais tempo, pela nova página referenciada que não foi encontrada. Como consequência o algoritmo pode substituir páginas que são usadas muito frequentemente, mas que foram colocadas na memória há muito tempo. Assim *Tanenbaum* afirma que "... em sua configuração pura, raramente é usado."

2. **Second-chance** - Constitui uma variação do algoritmo **FIFO**, pois adiciona uma *flag* na página relativa a referência, atualizando esse valor na primeira vez que a página for referenciada. Dessa forma, o algoritmo continua analizando as páginas pela ordem da lista, mas ao percorrer a lista, reinicia a *flag* daquelas que tiverem um valor positivo e as coloca no final da lista, até encontrar uma página cujo valor nunca foi atualizado, sendo esta a selecionada para a substituição. Assim nas palavras de *Tanenbaum* "razoável, mas desnecessariamente ineficaz, pois permanece constantemente reinserindo páginas no final da lista".

3. **NRU** - Substitui a página não usada recentemente considerando duas *flags*, a primeira relativa a referência que é atualizada sempre que a página é referenciada, e reiniciada a cada tick do relógio, e a segunda relativa a modificação, que é atualizada na primeira modificação sofrida pela página. Dessa forma, na hora de decidir qual página substituir, o algoritmo opta pela primeira que encontrar seguindo a ordem: não referenciada e não modificada; não referenciada e modificada; referenciada e não modificada; referenciada e modificada. Assim, o algoritmo considera páginas que foram referenciadas mais importantes que páginas que sofreram alteração, dessa forma existe um custo relativo a substituição da página modificada na memória. Como consequência disto, o autor *Tanenbaum* afirma que "... fornece um desempenho que, apesar de não ser ótimo, pode ser adequado."

4. **LRU** - Baseado na ideia de que as páginas mais recentemente utilizadas provavelmente serão utilizadas novamente nas próximas instruções, o algoritmo LRU sugere que, quando ocorrer uma falta de página, elimine a página não utilizada pelo maior período de tempo. Para implementar corretamente o LRU, é necessário que seja em hardware, pois é muito custoso. **Uma abordagem** é utilizar uma lista de páginas organizadas por tempo de última utilização, o que acaba saindo caro, pois, cada vez que alguma página for referenciada, a posição desta na lista deve mudar, além de que, se duas páginas forem referenciadas no mesmo tick de clock, estas não seriam diferenciadas. **Outra abordagem** é manter contadores em hardware para cada página, incrementado a cada *instrução* realizada e salva a cada referência à página, assim, a menos recentemente utilizado seria a que tivesse o menor contador. **Uma terceira abordagem** é utilizar matrizes de nxn bits (n = quantidade de molduras de página), e, sempre que uma moldura k for referenciada, todos os bits da linha k se tornam 1 e todos os bits da coluna k se tornam 0. Num instante qualquer, a linha cujo valor binário é o menor é o menos recentemente utilizado.

5. **Aging** -  Esse algoritmo é uma modificação do **NFU** (Not Frenquently Used), que por sua vez é uma modificação do **LRU** para que seja possível sua simulação em software. O **NFU** consiste em manter contadores em software (geralmente de 8 bits), que são incrementados pelo valor do bit **R** (se a página foi referenciada nesse instante) a cada tick de clock, e a página a ser removida seria o que tivesse o menor valor do contador. O problema desse algoritmo é que não esquece de nada, então páginas que foram muito referenciadas há muito tempo podem ter contadores altos. Para resolver esse problema, foi criado o algoritmo **Aging** (envelhecimento). Este consiste em, a cada tick de clock, o contador é deslocado à direita e o valor do bit **R** é adicionado ao bit mais às esquerda do contador, ao invés do bit mais à direita. A página a ser removida é aquela que tem o menor contador, pois, se não for referenciada por um tempo, terá valores 0 nos bits mais signifcativos. Há duas diferenças do **Aging** para o **LRU**: se temos duas páginas a escolher para remover A, de contador 00100000, e B, de contador 00100100, que não foram referenciadas nos últimos 2 ticks de clock, o LRU removeria aleatoriamente entre A e B, e o Aging removeria A, pois tem contador menor; se duas páginas não foram referenciados há mais de 8 ticks de clock, fazendo o contador chegar a 00000000, o Aging não tem como verificar qual página foi referenciada há mais tempo e removeria aleatoriamente entre as duas, e o LRU teria essa informação.
